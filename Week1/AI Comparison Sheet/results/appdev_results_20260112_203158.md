# APPDEV - AI Model Comparison Results

**Generated:** January 12, 2026 at 20:31:58

---

## System Prompt Used

```
You are an expert software engineer with 15+ years of experience in full-stack development. You specialize in writing production-ready, secure, and maintainable code.

**Your Expertise Includes:**
- Python (FastAPI, Django, Flask), JavaScript/TypeScript (React, Node.js, Express)
- RESTful API design, microservices architecture, authentication & authorization
- Clean code principles, SOLID design patterns, comprehensive error handling
- Security best practices (input validation, SQL injection prevention, XSS protection)
- Modern development practices (type hints, async programming, testing)

**Your Task:**
Generate high-quality, production-ready code that meets the following requirements:
1. **Correctness**: Code must work as specified without errors
2. **Security**: Implement proper input validation, error handling, and security measures
3. **Best Practices**: Follow language-specific conventions and modern patterns
4. **Completeness**: Include all necessary imports, type hints, and error handling
5. **Documentation**: Add clear comments explaining complex logic

**Output Format:**
- Provide complete, runnable code (not pseudocode or placeholders)
- Include all necessary imports at the top
- Use proper indentation and formatting
- Add inline comments for complex sections
- If using external libraries, specify them

**Code Quality Standards:**
âœ“ Type hints for function parameters and return values
âœ“ Comprehensive error handling with specific exception types
âœ“ Input validation with clear error messages
âœ“ Proper HTTP status codes (200, 400, 401, 403, 404, 422, 500)
âœ“ Security considerations (sanitization, authentication, authorization)
âœ“ Clean, readable, and maintainable code structure

Generate code that a senior developer would be proud to merge into production.
```

---

## Question 1: REST API with Validation

### Prompt
```
-------------------------------------
Create a Python FastAPI endpoint that:
- Accepts a POST request to /api/users
- Takes user data: name (required, 2-50 chars), email (required, valid format), age (optional, 18-120)
- Validates all inputs
- Returns JSON response with generated user_id
- Includes proper HTTP status codes (200, 400, 422)
- Has comprehensive error handling

Expected: Production-ready code with input validation, error handling, type hints
```


### ðŸ“Š Performance Metrics (1-5 Scale, AI-Evaluated)

| Model | Code Quality | Accuracy | Ease of Use | Speed | Explanation | Edge Cases | **Avg** |
|-------|--------------|----------|-------------|-------|-------------|------------|----------|
| Claude Sonnet 3.5 (AWS Bedrock) | â­â­â­â­â­ (5) | â­â­â­â­â­ (5) | â­â­â­â­â­ (5) | â­â­â˜†â˜†â˜† (2) | â­â­â­â­â­ (5) | â­â­â­â­â­ (5) | **4.5** |
| Meta Llama 3.2 90B (AWS Bedrock) | â­â­â­â­â­ (5) | â­â­â­â­â­ (5) | â­â­â­â­â­ (5) | â­â­â­â˜†â˜† (3) | â­â­â­â­â˜† (4) | â­â­â­â­â­ (5) | **4.5** |
| DeepSeek-Coder (Ollama Local) | â­â­â˜†â˜†â˜† (2) | â­â˜†â˜†â˜†â˜† (1) | â­â˜†â˜†â˜†â˜† (1) | â­â­â­â­â­ (5) | â­â­â˜†â˜†â˜† (2) | â­â˜†â˜†â˜†â˜† (1) | **2.0** |

#### ðŸ¤– AI Judge Reasoning

**Claude Sonnet 3.5 (AWS Bedrock):** The code demonstrates exceptional production readiness with comprehensive input validation, proper error handling, and complete type hints. It includes CORS middleware, detailed Pydantic models with custom validators, proper HTTP status codes, and thorough documentation. The implementation handles edge cases through email validation, name format checking, and proper exception handling with custom error responses.

**Meta Llama 3.2 90B (AWS Bedrock):** The code demonstrates excellent production-ready quality with proper input validation using Pydantic, comprehensive error handling, and clear type hints. It meets all requirements including proper HTTP status codes, input validation, and JSON responses. The code includes proper exception handling for both validation and unexpected errors, though could benefit from slightly more detailed inline documentation about the error scenarios.

**DeepSeek-Coder (Ollama Local):** The code is incomplete with placeholder comments and missing core functionality (user validation, proper models/schemas). Critical requirements like input validation, proper error handling, and HTTP status codes are not implemented. While it shows the basic FastAPI structure, it lacks production readiness and contains type ignore statements that shouldn't be needed in properly typed code.



### Detailed Responses

#### âœ… Claude Sonnet 3.5 (AWS Bedrock)

**Time:** 28.84s | **Status:** success

```
I'll create a production-ready FastAPI endpoint with comprehensive validation, error handling, and security measures. This code follows best practices and includes detailed type hints and documentation.

```python
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel, EmailStr, Field, validator
from typing import Optional
from uuid import uuid4
import re
from fastapi.responses import JSONResponse
from fastapi.middleware.cors import CORSMiddleware
from email_validator import validate_email, EmailNotValidError

# Initialize FastAPI app
app = FastAPI(title="User Management API")

# Configure CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # In production, replace with specific origins
    allow_credentials=True,
    allow_methods=["POST"],
    allow_headers=["*"],
)

class UserCreateRequest(BaseModel):
    """
    Pydantic model for user creation request validation.
    Includes custom validators and detailed error messages.
    """
    name: str = Field(
        ...,  # ... indicates required field
        min_length=2,
        max_length=50,
        description="User's full name (2-50 characters)"
    )
    email: EmailStr = Field(
        ...,
        description="User's email address"
    )
    age: Optional[int] = Field(
        None,
        ge=18,
        le=120,
        description="User's age (18-120)"
    )

    # Custom validators
    @validator('name')
    def validate_name(cls, value: str) -> str:
        """Validate name contains only allowed characters."""
        if not re.match("^[a-zA-Z .-]+$", value):
            raise ValueError("Name can only contain letters, spaces, dots, and hyphens")
        return value.strip()

    @validator('email')
    def validate_email_format(cls, value: str) -> str:
        """Additional email validation beyond Pydantic's built-in validation."""
        try:
            # Perform strict email validation
            valid = validate_email(value, check_deliverability=False)
      ...
```

*Response truncated. Full response in JSON file.*

#### âœ… Meta Llama 3.2 90B (AWS Bedrock)

**Time:** 11.70s | **Status:** success

```
**User Creation Endpoint with Input Validation and Error Handling**
===========================================================

```python
from fastapi import FastAPI, HTTPException, Request
from fastapi.responses import JSONResponse
from pydantic import BaseModel, EmailStr, validator
from typing import Optional

app = FastAPI()

class User(BaseModel):
    """User data model with validation"""
    name: str
    email: EmailStr
    age: Optional[int] = None

    @validator('name')
    def name_length(cls, v):
        """Validate name length (2-50 chars)"""
        if len(v) < 2 or len(v) > 50:
            raise ValueError("Name must be between 2 and 50 characters")
        return v

    @validator('age')
    def age_range(cls, v):
        """Validate age range (18-120)"""
        if v is not None and (v < 18 or v > 120):
            raise ValueError("Age must be between 18 and 120")
        return v

# In-memory user storage (replace with a database in production)
users = {}
user_id = 1

@app.post("/api/users", response_model=User, status_code=201)
async def create_user(user: User):
    """Create a new user with validated data"""
    global user_id
    try:
        # Validate user data
        validated_user = user.dict()
        
        # Generate a new user ID
        validated_user["user_id"] = user_id
        user_id += 1
        
        # Store the user in memory (replace with a database in production)
        users[validated_user["user_id"]] = validated_user
        
        # Return the created user with generated user ID
        return JSONResponse(content={"user_id": validated_user["user_id"]}, status_code=201)
    
    except ValueError as e:
        # Handle input validation errors
        raise HTTPException(status_code=422, detail=str(e))
    
    except Exception as e:
        # Handle unexpected errors
        raise HTTPException(status_code=500, detail="Internal Server Error")

# Example usage:
# curl -X POST -H "Content-Type: application/json" -d '...
```

*Response truncated. Full response in JSON file.*

#### âœ… DeepSeek-Coder (Ollama Local)

**Time:** 3.81s | **Status:** success

```
Here is a Python FastAPI endpoint that meets the requirements. This example uses Pydantic models for data validation and SQLAlchemy ORM to interact with an in memory database (for simplicity). You would replace this connection string by your actual DB URL or use something like Alembic if you were using more complex migrations:
```python
from fastapi import FastAPI, HTTPException  # type: ignore
from pydantic import BaseModel   # type: ignore
from sqlalchemy.orm import Session    # type: ignore
import string as st

app = FastAPI()
# In-memory SQLAlchemy database for simplicity's sake (you should use a proper DB) 
database_session =  {}     # replace this with your actual session or other ORM setup  
UserSchema  = None    # type: ignore, you would need to define UserModel and Schema in the next lines. This is just placeholder code for clarity's sake...
def getRandomString(length): 
      return ''.join(random.choice(st.ascii_uppercase + st.digits) for _ in range(length))   # this function should be replaced by a proper random string generator    
UserModel, UserSchema = None    # type: ignore you would need to define the models and schemas here...  (this is just placeholder code's sake...)     
@app.post("/api/users")       
def create_user( user : BaseModel , db: Session= Depends(database_session)) -> dict():   # type annotations, you would need to define the schema and model here...    (this is just placeholder code's sake...) 
      if not UserSchema or len(UserSchema.fields) != 3:     raise ValueError('Invalid user fields')       return {"user_id": getRandomString(10)}   # you should replace this with a proper function to create the new users...    (this is just placeholder code's sake...)
```  This example assumes that all necessary import statements are included at top, and appropriate indentation & formatting have been used. It also includes inline comments explaining complex sections of logic for better understanding by developers who read it or maintainers lo...
```

*Response truncated. Full response in JSON file.*

---

## Question 2: React Component with State Management

### Prompt
```
--------------------------------------------------
Create a React functional component for a Todo List that:
- Displays a list of todo items
- Has an input field to add new todos
- Allows marking todos as complete/incomplete with a checkbox
- Allows deleting todos with a button
- Uses React hooks (useState, useEffect)
- Includes proper TypeScript types (optional but preferred)
- Has basic styling (inline or CSS)

Expected: Clean component with proper state management and event handling
```


### ðŸ“Š Performance Metrics (1-5 Scale, AI-Evaluated)

| Model | Code Quality | Accuracy | Ease of Use | Speed | Explanation | Edge Cases | **Avg** |
|-------|--------------|----------|-------------|-------|-------------|------------|----------|
| Claude Sonnet 3.5 (AWS Bedrock) | â­â­â­â­â­ (5) | â­â­â­â­â­ (5) | â­â­â­â­â­ (5) | â­â­â˜†â˜†â˜† (2) | â­â­â­â­â˜† (4) | â­â­â­â­â˜† (4) | **4.2** |
| Meta Llama 3.2 90B (AWS Bedrock) | â­â­â­â­â­ (5) | â­â­â­â­â­ (5) | â­â­â­â­â­ (5) | â­â­â­â˜†â˜† (3) | â­â­â­â­â˜† (4) | â­â­â­â­â˜† (4) | **4.3** |
| DeepSeek-Coder (Ollama Local) | â­â˜†â˜†â˜†â˜† (1) | â­â˜†â˜†â˜†â˜† (1) | â­â˜†â˜†â˜†â˜† (1) | â­â˜†â˜†â˜†â˜† (1) | â­â˜†â˜†â˜†â˜† (1) | â­â˜†â˜†â˜†â˜† (1) | **1.0** |

#### ðŸ¤– AI Judge Reasoning

**Claude Sonnet 3.5 (AWS Bedrock):** The code demonstrates excellent production-ready quality with proper TypeScript types, clean organization, and comprehensive state management using React hooks. It includes proper styling, localStorage persistence, and input validation. While it has good error handling for basic cases, it could be enhanced with more robust error boundaries and loading states for localStorage operations.

**Meta Llama 3.2 90B (AWS Bedrock):** The code demonstrates excellent React/TypeScript practices with proper hooks usage, TypeScript interfaces, and clean component structure. It includes local storage persistence, input validation, error handling, and comprehensive CSS styling. While edge cases are handled well (empty input validation, localStorage checks), it could benefit from additional error handling for localStorage operations and more detailed inline documentation.

**DeepSeek-Coder (Ollama Local):** The response appears to be corrupted or incomplete, containing only repeated import statements for useEffect with the same comment. No actual Todo List implementation is provided. The code lacks any functional components, state management, event handlers, or TypeScript types as required. The response fails to meet any of the stated requirements.



### Detailed Responses

#### âœ… Claude Sonnet 3.5 (AWS Bedrock)

**Time:** 28.00s | **Status:** success

```
I'll create a production-ready React TodoList component with TypeScript, proper state management, error handling, and clean styling. I'll also include comments for clarity and implement best practices.

```tsx
// TodoList.tsx
import React, { useState, useEffect, ChangeEvent, FormEvent } from 'react';

// Define TypeScript interfaces
interface Todo {
  id: number;
  text: string;
  completed: boolean;
}

// Styles object for clean inline styling
const styles = {
  container: {
    maxWidth: '600px',
    margin: '2rem auto',
    padding: '2rem',
    boxShadow: '0 0 10px rgba(0,0,0,0.1)',
    borderRadius: '8px',
  },
  form: {
    display: 'flex',
    gap: '1rem',
    marginBottom: '1.5rem',
  },
  input: {
    flex: 1,
    padding: '0.5rem',
    fontSize: '1rem',
    borderRadius: '4px',
    border: '1px solid #ccc',
  },
  button: {
    padding: '0.5rem 1rem',
    backgroundColor: '#007bff',
    color: 'white',
    border: 'none',
    borderRadius: '4px',
    cursor: 'pointer',
    fontSize: '1rem',
  },
  todoItem: {
    display: 'flex',
    alignItems: 'center',
    padding: '0.75rem',
    backgroundColor: '#f8f9fa',
    marginBottom: '0.5rem',
    borderRadius: '4px',
  },
  todoText: (completed: boolean) => ({
    flex: 1,
    marginLeft: '0.5rem',
    textDecoration: completed ? 'line-through' : 'none',
    color: completed ? '#6c757d' : '#212529',
  }),
  deleteButton: {
    padding: '0.25rem 0.5rem',
    backgroundColor: '#dc3545',
    color: 'white',
    border: 'none',
    borderRadius: '4px',
    cursor: 'pointer',
  },
};

const TodoList: React.FC = () => {
  // State management using useState hook
  const [todos, setTodos] = useState<Todo[]>(() => {
    // Initialize todos from localStorage if available
    const savedTodos = localStorage.getItem('todos');
    return savedTodos ? JSON.parse(savedTodos) : [];
  });
  const [newTodo, setNewTodo] = useState<string>('');

  // Save todos to localStorage whenever they change
  useEffect(() => {
    localStora...
```

*Response truncated. Full response in JSON file.*

#### âœ… Meta Llama 3.2 90B (AWS Bedrock)

**Time:** 18.70s | **Status:** success

```
**TodoList.tsx**
```typescript
import React, { useState, useEffect } from 'react';
import './TodoList.css';

interface TodoItem {
  id: number;
  text: string;
  completed: boolean;
}

const TodoList: React.FC = () => {
  const [todos, setTodos] = useState<TodoItem[]>([]);
  const [newTodo, setNewTodo] = useState('');
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const storedTodos = localStorage.getItem('todos');
    if (storedTodos) {
      setTodos(JSON.parse(storedTodos));
    }
  }, []);

  useEffect(() => {
    localStorage.setItem('todos', JSON.stringify(todos));
  }, [todos]);

  const handleAddTodo = (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    if (!newTodo.trim()) {
      setError('Todo text cannot be empty');
      return;
    }
    const newTodoItem: TodoItem = {
      id: Date.now(),
      text: newTodo,
      completed: false,
    };
    setTodos([...todos, newTodoItem]);
    setNewTodo('');
    setError(null);
  };

  const handleToggleComplete = (id: number) => {
    const updatedTodos = todos.map((todo) =>
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    );
    setTodos(updatedTodos);
  };

  const handleDeleteTodo = (id: number) => {
    const updatedTodos = todos.filter((todo) => todo.id !== id);
    setTodos(updatedTodos);
  };

  return (
    <div className="todo-list">
      <h1>Todo List</h1>
      {error && <p style={{ color: 'red' }}>{error}</p>}
      <form onSubmit={handleAddTodo}>
        <input
          type="text"
          value={newTodo}
          onChange={(event) => setNewTodo(event.target.value)}
          placeholder="Add new todo"
        />
        <button type="submit">Add Todo</button>
      </form>
      <ul>
        {todos.map((todo) => (
          <li key={todo.id}>
            <input
              type="checkbox"
              checked={todo.completed}
              onChange={() => handleToggleComplete(todo.id)}
            />
 ...
```

*Response truncated. Full response in JSON file.*

#### âœ… DeepSeek-Coder (Ollama Local)

**Time:** 31.93s | **Status:** success

```
Here is the code for a Todo List in React. This includes all necessary imports, type hints (if used), error handling as well as best practices such as input validation using `useState` hook to manage user inputs within an array of todos which are then displayed on screen with appropriate styling and event handlers:
```tsx
import { useEffect } from 'react';  // Import the React Hooks (React, Component) here. Use "npm install react" if not already installed in your project or import as needed for each component separately using `useState` hook instead of this line only once at top level file like:
import { useEffect } from 'react';  // Import the React Hooks (React, Component) here. Use "npm install react" if not already installed in your project or import as needed for each component separately using `useState` hook instead of this line only once at top level file like:
import { useEffect } from 'react';  // Import the React Hooks (React, Component) here. Use "npm install react" if not already installed in your project or import as needed for each component separately using `useState` hook instead of this line only once at top level file like:
import { useEffect } from 'react';  // Import the React Hooks (React, Component) here. Use "npm install react" if not already installed in your project or import as needed for each component separately using `useState` hook instead of this line only once at top level file like:
import { useEffect } from 'react';  // Import the React Hooks (React, Component) here. Use "npm install react" if not already installed in your project or import as needed for each component separately using `useState` hook instead of this line only once at top level file like:
import { useEffect } from 'react';  // Import the React Hooks (React, Component) here. Use "npm install react" if not already installed in your project or import as needed for each component separately using `useState` hook instead of this line only once at top level file like:
im...
```

*Response truncated. Full response in JSON file.*

---

## Question 3: Authentication Function

### Prompt
```
------------------------------------
Write a Python function that:
- Takes a JWT token as input
- Validates the token (signature, expiration)
- Extracts user information (user_id, email, roles)
- Returns a user object or raises appropriate exceptions
- Handles expired tokens, invalid signatures, and malformed tokens
- Uses PyJWT library

Expected: Secure authentication with comprehensive error handling
```


### ðŸ“Š Performance Metrics (1-5 Scale, AI-Evaluated)

| Model | Code Quality | Accuracy | Ease of Use | Speed | Explanation | Edge Cases | **Avg** |
|-------|--------------|----------|-------------|-------|-------------|------------|----------|
| Claude Sonnet 3.5 (AWS Bedrock) | â­â­â­â­â­ (5) | â­â­â­â­â˜† (4) | â­â­â­â­â­ (5) | â­â˜†â˜†â˜†â˜† (1) | â­â­â­â­â˜† (4) | â­â­â­â­â­ (5) | **4.0** |
| Meta Llama 3.2 90B (AWS Bedrock) | â­â­â­â­â­ (5) | â­â­â­â­â­ (5) | â­â­â­â­â­ (5) | â­â­â­â˜†â˜† (3) | â­â­â­â­â­ (5) | â­â­â­â­â­ (5) | **4.7** |
| DeepSeek-Coder (Ollama Local) | â­â­â˜†â˜†â˜† (2) | â­â­â­â˜†â˜† (3) | â­â­â˜†â˜†â˜† (2) | â­â­â­â­â­ (5) | â­â­â­â˜†â˜† (3) | â­â­â˜†â˜†â˜† (2) | **2.8** |

#### ðŸ¤– AI Judge Reasoning

**Claude Sonnet 3.5 (AWS Bedrock):** The code demonstrates excellent production-quality implementation with comprehensive error handling, proper type hints, and clean object-oriented design. It includes robust security features, custom exceptions, and detailed logging. The only minor drawback is that the code appears to be truncated at the end, though the core functionality is complete.

**Meta Llama 3.2 90B (AWS Bedrock):** The code demonstrates excellent production-quality implementation with comprehensive error handling, proper type hints, and clear documentation. It follows security best practices for JWT validation, includes detailed docstrings, and handles all major edge cases (expired tokens, invalid signatures, malformed tokens). The example usage and security considerations provide additional valuable context for developers.

**DeepSeek-Coder (Ollama Local):** The code has several syntax errors (invalid comments, else clause placement) and security issues (hardcoded secret key). While it covers basic JWT validation, it lacks proper type hints, input validation, and comprehensive error handling. The explanatory comments are helpful but the code structure and implementation details need significant improvement for production use.



### Detailed Responses

#### âœ… Claude Sonnet 3.5 (AWS Bedrock)

**Time:** 33.17s | **Status:** success

```
I'll create a robust JWT validation function with comprehensive error handling and security best practices. This implementation uses PyJWT and follows production security standards.

```python
from datetime import datetime
from typing import Dict, Optional, Any
import jwt
from jwt.exceptions import (
    InvalidTokenError,
    ExpiredSignatureError,
    InvalidSignatureError,
    InvalidAudienceError,
    InvalidIssuerError,
)
from dataclasses import dataclass
from enum import Enum
import logging

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class TokenValidationError(Exception):
    """Custom exception for token validation errors"""
    pass

class UserRole(Enum):
    """Enum for user roles"""
    ADMIN = "admin"
    USER = "user"
    GUEST = "guest"

@dataclass
class User:
    """User data class to store validated token information"""
    user_id: str
    email: str
    roles: list[UserRole]
    additional_claims: Dict[str, Any]

class JWTValidator:
    """JWT token validation and user extraction class"""
    
    def __init__(
        self,
        secret_key: str,
        algorithm: str = "HS256",
        issuer: Optional[str] = None,
        audience: Optional[str] = None,
        leeway: int = 0
    ):
        """
        Initialize JWT validator with configuration parameters
        
        Args:
            secret_key: Secret key for token validation
            algorithm: JWT algorithm (default: HS256)
            issuer: Expected token issuer
            audience: Expected token audience
            leeway: Time leeway in seconds for token expiration
        """
        self.secret_key = secret_key
        self.algorithm = algorithm
        self.issuer = issuer
        self.audience = audience
        self.leeway = leeway

    def validate_and_decode_token(self, token: str) -> User:
        """
        Validate JWT token and extract user information
        
        Args:
            token: JWT token st...
```

*Response truncated. Full response in JSON file.*

#### âœ… Meta Llama 3.2 90B (AWS Bedrock)

**Time:** 12.05s | **Status:** success

```
**Secure JWT Token Validation and User Extraction**
=====================================================

### Dependencies

* `pyjwt`: For JWT token validation and decoding

### Code

```python
import jwt
from datetime import datetime
from typing import Dict, Optional

def validate_jwt_token(token: str, secret_key: str) -> Dict:
    """
    Validates a JWT token and extracts user information.

    Args:
    - token (str): The JWT token to validate
    - secret_key (str): The secret key used to sign the token

    Returns:
    - user_info (Dict): A dictionary containing user information (user_id, email, roles)

    Raises:
    - jwt.ExpiredSignatureError: If the token has expired
    - jwt.InvalidSignatureError: If the token signature is invalid
    - jwt.DecodeError: If the token is malformed
    - ValueError: If the token is missing required user information
    """

    try:
        # Attempt to decode the token with the provided secret key
        payload = jwt.decode(token, secret_key, algorithms=["HS256"])

        # Validate token expiration
        if payload["exp"] < datetime.now().timestamp():
            raise jwt.ExpiredSignatureError("Token has expired")

        # Extract user information from the payload
        user_id = payload.get("user_id")
        email = payload.get("email")
        roles = payload.get("roles")

        # Ensure required user information is present
        if not all([user_id, email, roles]):
            raise ValueError("Token is missing required user information")

        # Return the extracted user information
        return {"user_id": user_id, "email": email, "roles": roles}

    except jwt.ExpiredSignatureError as e:
        # Handle expired token
        raise jwt.ExpiredSignatureError("Token has expired") from e

    except jwt.InvalidSignatureError as e:
        # Handle invalid token signature
        raise jwt.InvalidSignatureError("Invalid token signature") from e

    except jwt.DecodeError as e:
        # Handle m...
```

*Response truncated. Full response in JSON file.*

#### âœ… DeepSeek-Coder (Ollama Local)

**Time:** 4.43s | **Status:** success

```
Here is the Python function that fulfills your requirements. It uses pyjwt for token validation along with a secret key to decode user information from JWTs (assuming you have this set up in environment variables). 
Please note, if PyJWT library isn't installed yet it can be done by running `pip install pyjwt`. The function also assumes that the token is passed as a string and has been correctly encoded using your secret key:
```python
import jwt
from fastapi import HTTPException  # or any other exception handling method you prefer, FastAPI doesn't handle exceptions itself but provides it through here for simplicity sake  

SECRET_KEY = 'your-secret-key'    # replace with your secret key (must be kept secure)
ALGORITHM  = 'HS256'  // or any other algorithm you want to use, PyJWT supports these algorithms. For example: "RS256" for RSA  

def validate_and_decode(token):    # function definition with JWT token as input parameter    
      try :        
          payload = jwt.decode(token , SECRET_KEY, algorithm=ALGORITHM)  // decoding the Token using secret key and PyJWT library  
          
        except jwt.ExpiredSignatureError:    // If token is expire then it raises ExpiredToken exception    
          raise HTTPException(status_code = 401, detail = 'The JWT has been expired')  # Returning appropriate error message to the user  
          
        except jwt.InvalidTokenError :      // if Token is Invalid or malformed then it raises an exception    
          raise HTTPException(status_code = 401, detail = 'The JWT was invalid due to some reason')  # Returning appropriate error message   
            
           return payload   // returning the decoded user information from token. This can be a dictionary or any object that you want it in your application    
      else :        
          raise HTTPException(status_code = 401, detail = 'The JWT was not provided')  # Returning appropriate error message to users if no Token is Provided  
```    // This function ...
```

*Response truncated. Full response in JSON file.*

---
